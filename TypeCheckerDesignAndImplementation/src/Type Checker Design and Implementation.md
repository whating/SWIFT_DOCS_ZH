[原文地址](https://github.com/apple/swift/blob/main/docs/TypeChecker.md)

## Purpose
本文档介绍 Swift 类型检查器的设计和实现。本文适用于想要修改、扩展或改进类型检查器的开发人员，同样也适用于想深入地了解 Swift 类型系统是如何工作的开发人员。本文假定你熟悉 Swift 语言。

## Approach
Swift 语言及其类型系统结合了许多流行的语言功能，包括面向对象编程中的类、函数和运算符重载、子类型和受约束的参数多态性。Swift  广泛使用了类型推断，从而可以省略许多变量和表达式的类型。例如：

```Swift
func round(_ x: Double) -> Int { /* ... */ }
var pi: Double = 3.14159
var three = round(pi) // 'three' has type 'Int'

func identity<T>(_ x: T) -> T { return x }
var eFloat: Float = -identity(2.71828)  // numeric literal gets type 'Float'
```

Swift 的类型推断允许类型信息的双向流动。在大多数主流语言中，类型信息可以从表达式树的叶节点（例如，表达式 `pi` ，它表示一个 double 类型）传递到根节点（变量 `three` 的类型）。但是，Swift 还允许类型信息从表达式树的根节点的上下文（例如，变量 `eFloat` 的固定类型）传递到叶节点（2.71828 的类型）。 这种双向类型推断在使用 ML-like 的类型系统的语言中很常见，但在主流语言（例如C ++，Java，C＃或Objective-C）中却不存在。

Swift 使用基于约束（constraint-based）的类型检查器实现双向类型推断，这使人想到经典的 Hindley-Milner 类型推断算法。约束系统的使用允许直接、通用的语言语义表示，这与求解器（solver）的实际实现是解耦的。 预计约束本身将会是相对稳定，而求解器将随着时间的推移来提高性能和诊断能力。

Swift 语言包含了大量不属于 Hindley-Milner 类型系统的特性，包括受约束的多态类型和函数重载，这在某种程度上使类型检查的表示和实现复杂化。另一方面，为了提供更好的性能和更好的诊断，Swift 将类型推断的范围限制在单个表达式或语句上。

类型检查分为以下三个主要阶段：

[Constraint Generation](#Constraint-Generation) 给定一个输入表达式和（可能的）附加上下文信息，生成一组类型约束，这些约束描述了各种子表达式的类型之间的关系。 生成的约束可能包含由类型变量表示的未知类型，这些类型将由求解器确定。

[Constraint Solving](#Constraint-Generation) 通过为约束系统中的每个类型变量分配具体类型来求解约束系统。 约束求解器应在不同的选择中提供可能的最具体的解决方案。

[Solution Application](#Solution-Application) 首先根据给定输入的表达式生成的类型约束集合，然后每个类型变量的具体类型的作业集将产生一个类型明确（well-typed）的表达式，该表达式使所有隐式转换（和其他转变）显式化并解析所有未知的类型和重载。 这个步骤不能失败。

下面几节将描述类型检查的这三个阶段，以及性能和诊断问题。

## Constraints
约束系统由一组类型约束组成。每个类型约束要么对单个类型(例如，整型文字类型)做出规定，要么关联两个类型(例如，一个是另一个的子类型)。约束中描述的类型可以是 Swift 类型系统包含的任何类型，例如，内置类型、元组类型、函数类型、枚举/结构体/类类型、协议类型和泛型类型。此外，类型可以是类型变量 `T`（通常编号为 `T0`，`T1`，`T2`等，并根据需要引入）。类型变量可以用来替代任何其他类型，例如，关联类型变量 `T0` 的元组类型 `(T0, Int， (T0) -> Int)`。

有多种不同的约束用于描述 Swift 的类型系统：

**Equality** 等式约束要求两种类型完全相同。例如，约束 `T0 == T1` 有效地确保 `T0` 和 `T1` 绑定相同的具体类型。等式约束有以下两种不同的类型:
- 精确的等式约束或“绑定”：对于某些类型变量 `T0` 和类型 `X`，写为 `T0：= X`，这种类型要求 `T0` 与 `X` 完全相同；
- 等式约束：对于类型 `X` 和类型 `Y`，写为 `X == Y`，这种要求 `X` 和 `Y` 具有相同的类型，而忽略相等性判断过程中的左值类型。 例如，约束 `T0 == X` 将通过为 `T0` 分配类型 `X` 和通过为 `T0` 分配类型 `@lvalue X` 来满足相等性。

**Subtyping** 子类型约束要求第一个类型等价于第二个类型或是第二个类型的子类型。例如，如果 `Dog` 直接或间接继承自 `Animal` ，那么 `Dog` 是 `Animal` 的子类型。 子类型约束写作 `X < Y`。

**Conversion** 转换约束要求第一种类型可以转换为第二种类型，其中包括 subtyping 和 equality。此外，它允许调用用户自定义的转换函数。转换约束写作 `X <c Y`，读为“ `X` 可以转换为 `Y`”。

**Construction** 构造约束要求第二种类型是标称类型（nominal type），其构造函数接受第一种类型的值，写作 `X <C Y`。例如，约束 `Int <C String` 是可以满足的，因为 `String` 具有接受 `Int` 类型参数的构造函数。

**Member** 成员约束 `X[.name] == Y` 指定第一种类型（`X`）具有给定名称的成员（或成员的重载集合），并且该成员的类型能够绑定到第二种类型（`Y`）上。成员约束有以下两种类型：
- 值成员约束，它引用表达式上下文中的成员
- 类型成员约束，它引用类型上下文中的成员（因此只能引用类型）

**Conformance** 符合性约束 `X conforms to Y` 表示第一种类型（`X`）必须符合协议 `Y`。

**Checked cast** 描述从第一种类型到第二种类型强制转换的约束，例如，`x as T`。

**Applicable function** 可应用的函数约束要求两种类型都是具有相同输入和输出类型的函数类型。为了实现函数应用（function application）的目的，将左侧的函数类型分割为其输入和输出类型时使用它。注意，它不需要匹配类型属性。

**Overload binding** 重载绑定约束通过从重载集合中选择特定选项来绑定类型变量。多个重载由析取约束表示。

**Conjunction** 由两个或多个其他约束合取的约束。通常在析取约束中使用。

**Disjunction** 由两个或多个约束析取得到的一种约束。析取约束用于为求解器可能做出的不同决策建模，例如，求解器可能选择的重载函数集，或者可能在(不同的)解决方案中得到解决的不同的潜在转换。

**Archetype** 原型约束要求将受约束的类型绑定到原型上。这是一种非常特殊的约束，仅用于协议中对运算符的调用。

**Class** 类约束要求将受约束的类型绑定到类类型上。

**Self object of protocol** 一种仅在内部使用的约束，描述了 `Self` 类型与协议的一致性。它类似于符合性约束，但“更宽松”，因为它允许协议类型成为其自身协议的 self 对象（即使存在的类型不符合其自身协议）。

**Dynamic lookup value** 要求约束类型为 DynamicLookup 或其左值的一种约束。

### Constraint Generation
约束生成过程会生成一个约束系统，该约束系统将表达式中各个子表达式的类型关联起来。通过编程的方式，约束的生成将表达式从叶节点遍历到根节点，并为每个子表达式分配类型(通常涉及类型变量)。

约束的生成是由表达式的语法驱动的，每一种不同的表达式——函数应用（Function application）、成员访问等——都会生成一组特定的约束。在这里，我们枚举 Swift 语言中的主要表达式类型，并描述了分配给该表达的类型以及从该表达生成的约束。我们使用 `T(a)` 来指代分配给子表达式 `a` 的类型。由主要表达式类型生成的约束和类型有以下几种:

**Declaration reference** 声明 `x` 的表达式被分配了 `x` 的引用类型。例如，如果 `x` 被声明为 `var x: Int`，则表达式 `x` 被赋值为 `@lvalue Int`。这种情况不会产生任何约束。

当名称引用一组重载声明时，求解器将处理并选择适当的声明。在 [Overloading](#Overloading) 部分将讨论这个问题。另外，当名称引用泛型函数或泛型类型时，声明引用可能会引入新的类型变量，请参见 [Polymorphic Types](#Polymorphic-Types) 部分获取更多信息。

**Member reference** 成员引用表达式 `a.b` 的类型被分配为新的类型变量 `T0` 。此外，表达式生成了值成员约束 `T(a).b == T0`。成员引用可能最终解析为标称类型的成员或元组的元素； 在后一种情况下，名称（`b`）可以是标识符，也可以是位置参数（例如 `1`）。

注意，成员约束的解析可以引用一组重载声明。 这将在 [Overloading](#Overloading) 部分中进一步描述。

**Unresolved member reference** 未解析的成员引用表示枚举类型的成员， 如 `.name`。枚举类型假定有一个新变量类型 `T0` （因为只能从上下文中知道该类型），并且对于新类型变量 `T1` 的值成员约束 `T0.name == T1` 具有以下属性：它有一个类型为 `T1` 的成员变量 `name` ，而且 `T1` 的类型尚未知晓。未解析的成员引用的类型为 `T1`，即成员的类型。当未解析的成员引用实际上是调用 `.name(x)` 时，函数应用将被放入未解析的成员引用生成的约束中。

注意，在没有附加上下文信息的情况下，上面的约束系统实际上没有足够的信息来确定类型 `T0`。[Overloading](#Overloading) 部分描述了如何使用重载选择机制来解决此问题。

**Function application** 函数应用 `a(b)` 生成两个约束。首先，可应用的函数约束 `T0 -> T1 ==Fn T(a)`（对于新类型变量 `T0` 和 `T1`）捕获应用于函数（`a`）的右值到左值的转换，并将函数类型分解为其参数和返回值的类型。其次，转换约束 `T(b) <c T0` 捕获了将实际参数类型（`b`）转换为函数的参数类型的要求。最后，表达式的类型被赋为 `T1`，即函数的返回值的类型。

**Construction** 类型构造表达式 `A(b)`，其中 `A` 指的是类型，生成构造约束 `T(b) <C A`，这要求类型 `A` 有一个接受 `b` 类型的构造函数。表达式的类型是 `A`。

注意，构造表达式和函数应用使用相同的语法。在这里，约束生成器对“function”参数的类型（在上面的说明中是 `A` 或 `a`）进行浅层分析；如果表达式明显具有 metatype 类型，则将其视为强制/构造表达式，而不是函数应用。Swift 语言的在这种特殊情况下生成约束时需要更多的工作。

**Subscripting** 下标操作 `a[b]` 类似于函数应用。值成员约束 `T(a).subscript == T0 -> T1` 视为从键类型到值类型的函数，分别由新的类型变量 `T0` 和 `T1` 表示。约束 `T(b) <c T0` 要求键参数可转换为键类型，并且下标操作的类型为 `T1`。

**Literals** 文字表达式（例如 `17`、`1.5` 或`"Hello，world!"`）被分配了一个新的类型变量 `T0`。此外，根据文字的种类，在该类型变量上设置了文字约束，例如，“`T0` is an integer literal。”

**Closures** 根据参数和返回类型为闭包分配函数类型。当参数没有指定的类型或位置（`$1`，`$2` 等）时，将为它分配一个新的类型变量以捕获该类型。 同样，如果省略了返回类型，则会为它分配一个新的类型变量。

当闭包的主体是单个表达式时，该表达式直接参与对其封闭表达式的类型检查。 否则，一旦其上下文的类型检查已计算出完整的函数类型，就将分别对闭包的主体进行类型检查。

**Array allocation** 数组构造表达式 `new A[s]` 被分配为类型 `A[]`。类型检查器（单独）检查 `T(s)` 是否为数组绑定类型。

**Address of**  取地址表达式 `＆a` 始终返回 `@inout` 类型。因此，对于新的类型变量 `T0`，它被赋值为类型 `@inout T0`。子类型约束 `@inout T0 < @lvalue T(a)` 捕获了输入表达式必须是某种类型的左值的要求。

**Ternary operator** 三元运算符表达式 `x ? y : z` 生成了许多约束。首先类型 `T(x)` 必须符合 `LogicValue` 协议才可以确定采用哪个分支。然后，引入新的类型变量 `T0` 来捕获结果类型，并且约束条件 `T(y) <c T0` 和 `T(z) <c T0` 捕获了三元运算符的两个分支转换为普通类型的需求。

在 Swift 语言中还有许多其他种类的表达方式；有关它们到约束的映射，请参阅约束生成器。

#### Overloading
重载是对同一个名称给出多个不同定义的过程。例如，我们可以重载一个 `negate` 函数来同时处理 `Int` 和 `Double` 类型，例如:

```Swift
func negate(_ x: Int) -> Int { return -x }
func negate(_ x: Double) -> Double { return -x }
```

`negate` 有两种定义，那么声明引用表达式 `negate` 的类型是什么呢？如果选择第一个重载，类型是 `(Int) -> Int`；对于第二个重载，类型是 `(Double) -> Double`。但是，约束的生成需要为表达式分配某种特定类型，以便其父表达式可以引用该类型。

通过为引用重载的声明的类型引入新的类型变量（称为 `T0`）来对类型检查器中的重载进行建模。然后，引入析取约束，其中每项将类型变量（通过精确相等约束）绑定到由重载集合中的一个重载产生的类型。在 `negate` 的示例中，析取约束为 `T0: = (Int) -> Int or T0: = (Double) -> Double`。约束求解器（稍后在 [Constraint Solving](#Constraint-Solving) 一节中讨论）探索了两种可能的绑定，并且重载的引用解析为在满足所有约束的解决方案中的任何绑定结果。这两种重载都可能会生成同一个解决方案，在这种情况下，解决方案将根据 [Comparing Solutions](#Comparing-Solutions) 一节中讨论的规则进行排序。

重载既可以由引用重载声明集的表达式引入，也可以由最终解析为重载声明集的成员约束引入。一个特别有趣的情况是未解析的成员引用，例如 `.name`。如前所述，这会生成约束 `T0.name == T1`，其中 `T0` 是一个将被绑定到枚举类型的新类型变量，而 `T1` 是一个将被绑定到所选成员的类型的新类型变量。在前一节中提到的问题是这个约束没有给求解器足够的信息来不进行猜测就确定 `T0` 的类型。但是，我们注意到枚举成员的类型实际上是一个规则的结构体。例如，考虑 `Optional` 类型：

```Swift
enum Optional<T> {
    case none
    case some(T)
}
```

`Optional<T>.none` 的类型是 `Optional<T>`，而 `Optional<T>.some` 的类型是 `(T) -> Optional<T>`。实际上，枚举元素的类型可以有两种形式：一种形式是 `T0`，这是没有额外数据的枚举元素；另一种形式是 `T2 -> T0`，其中 `T2` 是与枚举元素关联的数据。对于后一种情况，实际的参数作为未解析成员引用的一部分进行解析，以便函数应用约束描述它们如何转换到输入类型 `T2`。

#### Polymorphic Types
Swift 语言包括泛型，这是一个约束参数多态性的系统，支持多态类型和多态函数。例如，可以实现一个 `min` 函数：

```Swift
func min<T : Comparable>(x: T, y: T) -> T {
    if y < x { return y }
    return x
}
```

在这里，`T` 是一个可以用任何具体类型替换的泛型参数，只要这个具体的类型符合 `Comparable` 协议就可以。`min` 的类型（内部）写作 `<T: Comparable> (x: T, y: T) -> T`，可以读为“对于所有 `T`，其中 `T` 符合 `Comparable` 协议，函数的类型是 `(x: T, y: T) -> T`”。`min` 函数的不同用法可能会对泛型参数 `T` 有不同的绑定。

当约束生成器遇到对泛型函数的引用时，它将立即用新的类型变量替换函数类型内的每个泛型参数，然后在该类型变量上引入约束以匹配泛型函数中列出的约束，并产生一个基于新生成的类型变量的单态函数类型。例如，声明引用表达式 min 的首次出现将生成类型 `(x : T0, y : T0) -> T0`，其中 `T0` 是新的类型变量，以及表示协议一致性的子类型约束 `T0 < Comparable`。下一次声明引用表达式 `min` 的时将生成类型 `(x : T1, y : T1) -> T1`，其中 `T1` 是新的类型变量（因此不同于 `T0`），依此类推。这种替换过程被称为“opening”泛型函数类型，是在约束系统内建模多态函数时使用的一种非常简单（但有效）的方法，而不会使求解器复杂化。注意，这种泛型函数类型的立即打开是有效的，因为 Swift 不支持一级多态函数，例如，不能声明一个类型为 `<T> T -> T` 的变量。

约束求解器还会立即打开泛型类型的使用。例如，考虑以下范型字典类型：

```Swift
class Dictionary<Key : Hashable, Value> {
    // ...  
}
```

当约束求解器遇到表达式 `Dictionary()` 时，它把 `Dictionary` 类型 ——它没有提供任何特定的泛型参数——开放给 `Dictionary<T0, T1>` 类型，其中 `T0` 和 `T1` 新的类型变量，并引入 `T0 conforms to Hashable` 约束。这允许通过表达式的上下文确定字典实际的键类型和值类型。如上所述，对于一级多态函数，这种立即打开是有效的，因为未绑定的泛型类型（没有指定泛型参数的类型）不能使用，除非泛型参数可以推断。

### Constraint Solving
约束求解器的主要目的是获取一组给定的约束，并为约束系统中的每个类型变量确定最具体的类型绑定。作为此目标的一部分，约束求解器还通过选择重载之一来解析重载的声明引用。

在最坏的情况下，求解 Swift 语言生成的约束系统的时间是指数级增长的。即使是经典的 Hindley-Milner 类型推断算法需要的时间也是指数级增长的，而 Swift 类型系统引入了额外的复杂性，特别是重载解析。但是，对于任何特定的表达式花费时间都是很少的，而且约束求解器可以使用许多技巧来提高性能。Performance 部分描述了一些已经实现或正在计划的技巧，并且预计该求解器将随着更多技巧的增长而扩展。

本节将重点介绍求解器设计背后的基本思想及其所适用的类型规则。

#### Simplification
约束生成过程引入了许多可以立即解决的约束，这些约束可以直接解决（因为解决方案很明显而且很简单），也可以通过将约束分解为许多更小的约束来解决。此过程称为简化（simplification），它规范化了约束系统，供后续约束解决阶段使用。每次约束求解器进行猜测时（例如，在解决重载或绑定类型变量时）也会重新调用它，因为通常每次这样的猜测都会导致其他简化产生。当所有的类型变量和重载都被解决后，通过检测一个没有被满足的平凡约束（trivial constraint）（因此，这不是一个合适的解决方案）或者将约束集减少到很容易（trivially）满足的简单约束来终止约束求解过程。

简化过程将约束分解为更简单的约束，并且每种不同类型的约束由基于 Swift 类型系统的不同规则处理。约束可分为五类:关系约束、成员约束、类型属性、合取和析取。前三种约束具有有趣的简化规则，并将在以下部分进行讨论。

##### Relational Constraints
关系约束描述了两种类型之间的关系。这个部分涵盖了等式约束，子类型约束和转换约束，并提供了最常见的简化方法。通过比较两种类型的结构并应用 Swift 语言的类型规则来生成其他约束来简化关系约束。例如，如果约束是转换约束：

```
A -> B <c C -> D
```

这两种类型都是函数类型，我们可以通过对函数类型应用转换规则将这个约束分解为两个较小的约束 `C < A` 和 `B < D`。类似地，可以销毁所有类型构造函数——元组类型、泛型类型、左值类型等等——以根据语言[1]的类型规则生成更简单的要求。

涉及一方或双方的类型变量的关系约束通常不能直接解决。相反，这些约束稍后通过提供可能的类型绑定（在 Type [Variable Bindings](#Type-Variable-Bindings) 部分中介绍）来通知解决过程。两个类型变量之间的等式约束是个例外，例如 `T0 == T1`。通过统一 `T0` 和 `T1` 的等价类（使用 union-find 算法）简化了这些约束，这样求解器只需要确定一个类型变量的类型绑定（而另一个变量得到相同的类型绑定）就可以了。

##### Member Constraints
成员约束指定某种类型具有指定名称的成员，并为该成员的类型提供绑定。`A.member == B` 是一个成员约束，当 `A` 的类型被确定为标称类型或元组类型时这个约束可以被简化，在这种情况下，名称查找可以将成员名称解析为一个实际的声明。该声明的类型为 `C`，因此成员约束被简化为确切的等式约束 `B:= C`。

成员名可以引用一组重载声明。在本例中，类型 `C` 是一个新的类型变量（称为 `T0`）。如 Overloading 一节中所述，引入了析取约束，新的重载集将不同的声明类型绑定到 `T0`。

成员约束的类型——类型或值——也会影响声明类型 `C`。类型约束只能引用成员类型，而 `C` 将是已命名成员的声明类型。另一方面，值约束可以引用类型或值，而 `C` 是对该实体的引用的类型。对于类型的引用，`C` 将是已声明类型的元类型。

#### Strategies
约束求解的基本方法是简化约束，直到约束无法再简化为止，然后产生（并检查）有根据的猜测，这些猜测是关于应从重载集中选择哪个声明或应将哪种具体类型绑定到给定的类型变量。每一种猜测都作为一种假设进行测试，也可能与其他猜测一起进行测试，直到求解器得出解决方案或得出猜测是不正确的为止。

在实现中，每个猜测都被建模为新求解器作用域内的假设。求解器作用域继承其父求解器作用域的所有约束、重载选择和类型变量绑定，然后再添加一个猜测。因此，求解器探索的解空间可以看作是一棵树，其中最顶端的节点是直接从表达式生成的约束系统。树的叶子节点要么是类型检查问题的解决方案（所有的约束都被简化了），要么是表示不能产生解决方案的一组假设。

以下各节描述了求解器用来生成探索求解空间的派生约束系统的技术。

##### Overload Selection
重载选择是进行假设的最简单的方法。对于将析取约束 `T0 := A1 or T0 := A2 or ... or T0 := AN` 引入约束系统的重载集，重载选择将单独访问析取中的每个项。每个求解器状态都绑定类型变量 `T0`，并探究所选的重载是否会生成合适的解决方案。

##### Type Variable Bindings
求解器进行假设的第二种方法是猜测一个给定的类型变量应该被绑定到的具体类型。然后将该类型绑定引入到新的派生约束系统中，以确定该绑定是否可行。

求解器不会凭空变出具体的类型绑定，也不会执行遍历搜索。相反，它使用对该类型变量施加的约束来生成潜在的候选类型。求解器在产生类型变量绑定时采用了以下几种策略。

###### Meets and Joins
给定的类型变量 `T0` 通常存在关系约束，这些约束将它与具体类型关联起来，例如 `T0 <c Int` 或 `Float <c T0`。在这些情况下，我们可以使用具体类型作为起点来对类型 `T0` 进行有根据的猜测。

为了确定合适的猜测，对放置在类型变量上的关系约束进行了分类。给定形式为 `T0 <? A`  的关系约束（ `<?`是 `<`、`<t` 或 `<c` 中的一个），其中 `A` 是某种具体类型，`A` 被称为“above” `T0`。类似地，给定形式为 `B <? T0` 的约束，其中 `B` 为具体类型，`B` 被称为“below” `T0`。above/below 的术语来自于由转换关系形成的可视化的类型格，例如，如果 `A` 可以转换为 `B`，则在后者中有一条边 `A -> B`。因此，`B` 在格子里比 `A` 要高，格子里最上面的元素是所有类型都可以转换为的元素（通常称为“top”）。

“above”和“below”给定类型变量的具体类型为可分配给该类型变量的可能的具体类型提供了边界。求解器计算[2]类型变量“below”的类型的连接，即所有“below”类型可以转换为的最具体（最低）类型的连接，并将该连接用作初始猜测。

###### Supertype Fallback
由于涉及类型变量的约束还不够简单，无法算作联接的一部分，因此作为初始点计算的“below”类型的联接可能过于具体。为了处理这种情况，如果无法找到“below”类型联接的解决方案，则求解器创建一组新的派生约束系统，这些约束系统具有较弱的假设，对应于连接可以直接转换为的每种类型。例如，如果联接是某个类 `Derived`，那么超类型回退（supertype fallback）就会尝试 `Derived` 类直接继承的 `Base` 类。这个回退过程将继续，直到所生成的类型不再可以转换为类型变量“above”的类型，即可以转换为类型变量“above”的所有类型的最低特定（最高）类型[3]。

###### Default Literal Types
如果类型变量通过一致性约束绑定到一个文字协议，即 “`T0` conforms to `ExpressibleByIntegerLiteral`”，那么约束求解器将猜测该类型变量可以绑定到该协议的默认文字类型。例如，`T0` 将获得默认的整型文字类型 `Int`，从而允许对由于类型信息太少而无法确定这些文字类型的表达式进行类型检查，例如 `-1`。

##### Comparing Solutions
求解器将探索一个潜在的较大解空间，并且有可能找到给定约束系统的多个解。这样的情况下解决方案不一定是模棱两可的，因为求解器随后可以比较解决方案以确定一个解决方案是否比其他所有解决方案都要好。为此，它基于许多因素为每个解决方案计算了一个“分数”：
- 应用了多少用户自定义的转换。
- 应用了多少非平凡函数转换。
- 有多少文字被赋予了“non-default”类型。

分数较小的解决方案被认为是更好的解决方案。当两个解决方案的得分相同时，将比较两个系统的类型变量和重载选择以产生相对得分：
- 如果这两个解决方案为一个类型变量选择了不同的类型变量绑定，那么“更具体”的类型变量是更好的匹配，并且其中一个解决方案的类型变量绑定是另一个解决方案的子类型，那么具有子类型的解决方案的分数将+1。
- 如果重载集在两个解决方案中有不同的选择重载，则对重载进行比较。如果在一个解决方案中挑选的重载类型是在另一个解决方案中挑选的重载类型的子类型，那么第一个解决方案的分数将+1。

相对分数较高的解决方案被认为比其他解决方案更好。

### Solution Application
一旦求解器生成了约束系统的解决方案，该解决方案必须应用于原始表达式，以生成一个完全类型检查的表达式，生成的表达式使所有隐式转换和解析的重载都显式化。这个应用过程将表达式树从叶子节点遍历到根节点，并根据表达式的类型重写每个表达式节点：

*Declaration references* 声明引用将使用所引用的精确声明类型进行重写。对于重载的声明引用，将 `Overload*Expr` 节点替换为简单的声明引用表达式。对于多态函数或泛型类型成员的引用，将引入一个 `SpecializeExpr` 节点来提供对所有泛型参数的替换。

*Member references* 对成员的引用类似于声明引用。但是，它们添加了基本表达式需要作为引用的约束。因此，将实现一个 non-reference 类型的右值以产生必要的引用。

*Literals* 文本被转换为适当的文本类型，这通常涉及为适当的文本协议引入对见证人（witnesses）的调用。

*Closures* 因为闭包已经是一个完整的函数类型，所以用这个完整的函数类型对闭包的主体进行类型检查。
对于用约束系统建模的任何类型检查规则，解决方案应用程序步骤都不能出错。但是，有一些错误是故意留给解决方案应用程序阶段的，比如应用于 non-optional 类型的后缀 '!'。

#### Locators
在约束生成和求解过程中，大量的约束会生成、分解和求解。在约束应用程序和诊断发布过程中，跟踪约束与它们最初来自的实际 AST 节点之间的关系非常重要。例如，考虑以下类型检查问题：

```Swift
struct X {
    // user-defined conversions
    func [conversion] __conversion () -> String { /* ... */ }
    func [conversion] __conversion () -> Int { /* ... */ }
}

func f(_ i : Int, s : String) { }

var x : X
f(10.5, x)
```

该约束系统生成约束“`T(f)` ==Fn `T0 -> T1`”（对于新变量 `T0` 和 `T1`）和“`(T2, X) <c T0`”（对于新变量 `T2`），其中“`T2` conforms to `ExpressibleByFloatLiteral`”。作为解决方案的一部分，在 `T0` 被替换为 `(i: Int, s: String)` 之后，第二个约束被分解为“`T2 <c Int`”和“`X <c String`”。由于不同的原因，这两个约束表现会很有趣：第一个将会失败，因为 `Int` 不符合 `ExpressibleByFloatLiteral`。第二个约束将通过选择一个(重载的)转换函数而成功。

在这两种情况下，我们都需要将实际的约束映射回它们引用的表达式。在第一种情况下，我们不仅要报告由于 `Int` 不符合 `ExpressibleByFloatLiteral` 而导致的失败，而且还要指出 `Int` 类型实际上是从参数中来的。在第二种情况下，我们希望确定选择了哪个重载的转换函数来执行转换，以便在所有其他操作都成功时，约束应用程序可以调用转换函数。

定位器通过跟踪约束的位置和派生来解决这两个问题。每个定位器都锚定在一个特定的 AST 节点上(表达式、模式、声明等)，例如，函数应用 `f(10.5, x)`，并包含从该锚定中零个或多个派生步骤的路径。例如，约束“`T(f)` ==Fn `T0 -> T1`”有一个定位器，该定位器锚定在函数应用中，并且这个约束带有“apply function”派生步骤的路径，这意味着这是正在应用的函数。类似地，“`(T2, X) <c T0`”约束有一个锚定在函数应用上的定位器和一个带有“apply argument”派生步骤的路径，这意味着这是函数的参数。

当约束被简化时，产生的约束的定位器具有更长路径。例如，当两个元组之间的转换约束被简化为对应元组元素之间的转换约束时，得到的定位器将引用特定的元素。例如，约束 `T2 <c Int` 的定位器将锚定在函数应用上(仍然是)，并且在其路径中有两个派生步骤：从父约束派生的“apply function”派生步骤，后面是引用这个特定元组元素的约束“tuple element 0”。类似地，约束 `X <c String` 将具有相同的定位器，但使用的是“tuple element 1”而不是“tuple element 0”。 约束求解器中的 `ConstraintLocator` 类型具有许多不同的派生步骤类型（在源代码中称为“path elements”），这些派生步骤描述了将较大的约束分解为较小约束的各种方式。

##### Overload Choices
每当求解器创建新的重载集时，该重载集都与特定定位器相关联。继续上一节的示例，求解器将创建一个包含两个用户定义的转换的重载集。此重载集是在简化约束 `X <c` 字符串时创建的，因此它使用由“conversion member”派生步骤扩展的约束中的定位器。因此，此重载集的完整定位器是：

```
function application -> apply argument -> tuple element #1 -> conversion member
```

当求解器从重载集中选择一个特定的重载时，它根据重载集中的定位器记录所选择的重载。当需要执行约束应用程序时，将根据上下文重新创建定位器（自下而上的遍历表达式以使用最终类型重写表达式），而且定位器会用于查找要调用的适当转换。当表达式直接引用重载函数时，使用相同的机制来选择适当的重载。此外，当比较同一约束系统的两个解决方案时，可以通过比较每个解决方案中每个重载选择的定位器来找到两个解决方案中都存在的重载集。当然，所有这些操作都要求在约束系统中定位器是唯一的。

###### Simplifying Locators
定位器提供了遵循求解器路径的位置信息的派生，并可用于查询和恢复求解器所做的重要决策。但是，由求解器确定的定位器可能不会直接引用最特定的 AST 节点来标识对应的源位置。例如，失败的约束“`Int` conforms to `ExpressibleByFloatLiteral`”非常具体地以浮点文字 `10.5` 为中心，但是它的定位器是:

```
function application -> apply argument -> tuple element #0
```

定位器简化过程将定位器映射到其最特定的 AST 节点。本质上，它从定位器的锚点开始（在本例中是应用程序 `f(10.5, x)`），然后遍历路径，将派生步骤匹配到子表达式。“function application”派生步骤提取自参数（`(10.5,x)`）。然后，“tuple element #0”推导提取出元组元素0的子表达式 `10.5`，这时我们遍历了整个路径，现在具有用于 source-location 目的的最特定表达式。

定位器的简化并不总是穷举完整的路径。例如，考虑对我们的例子做一个小小的修改，使 `f` 的参数由另一个调用者提供，我们得到一个完全不同的结果:

```Swift
func f(_ i : Int, s : String) { }
func g() -> (f : Float, x : X) { }

f(g())
```

以下，是失败的约束是 `Float <c Int` 的定位器，使用与上一个调用相同的定位器：

```
function application -> apply argument -> tuple element #0
```

当我们简化这个定位器时，我们从 `f(g())` 开始。“apply argument”派生步骤将我们带到参数表达式 `g()`。但是，这里没有 `g()` 的第一个元组元素的子表达式，因为它是从 `g` 返回的元组的简单部分。此时，简化停止，并创建简化的定位器：

```
function application of g -> tuple element #0
```

### Performance
类型检查器的性能取决于许多因素，但主要问题的是解空间的大小（在最坏情况下耗时是指数型的）和求解器探索解空间的有效性。本节介绍了一些用于提高求解器性能的一些技术，其中许多技术无疑可以进一步优化。

#### Constraint Graph
约束图描述了约束系统中类型变量之间的关系。约束图中的每个顶点对应一个类型变量。约束图的边对应于约束系统中将类型变量集联系在一起的约束。从技术上讲，这使约束图成为多重图，尽管内部表示更类似于具有多种边的图：每个顶点（节点）跟踪提到的给定类型变量的约束集以及与该类型变量相邻的类型变量集。顶点还包括一些信息，这些信息是关于与给定类型变量（当类型变量已合并时）对应的等价类或类型变量与特定类型的绑定。

约束图对于许多求解器优化是至关重要的。例如，用于计算约束图内的连通分量，使得每个连通分量都可以独立求解。然后来自所有连通分量的部分结果被组合成一个完整的解决方案。另外，约束图可用于指导简化，如下所述。

#### Simplification Worklist
当求解器尝试了类型变量绑定时，该绑定通常会导致约束系统中额外的简化。求解器将查询约束图以确定哪些约束提到了相同的类型变量，并将这些约束放到简化工作清单中。如果可以进一步简化这些约束，则可能导致额外的类型变量绑定，从而又向工作清单中添加了更多约束。一旦工作清单处理完，简化就完成了。使用工作清单消除了重新处理未更改约束的需要，约束不更改的原因是因为它们提到的类型变量没有更改。

#### Solver Scopes
求解器以深度优先的方式遍历求解空间。每当求解器准备进行猜测时——比如推测类型变量绑定或从析取中选择术语——它都会引入一个新的求解器作用域来捕获该假设的结果。在求解器建立一组假设时，将嵌套后续的求解器作用域，最终能够求出解果或导致错误。求解器范围的堆栈包含生成该解决方案所需的所有假设，并保存在一个单独的解决方案数据结构中。

求解器作用域本身被设计为创建和销毁的开销都很小。为了支持这一点，约束求解器使用的所有主要数据结构都具有可逆操作，从而使求解器可以轻松地回溯。例如，在约束图中添加的约束可以通过删除相同的约束来回溯。约束图跟踪堆栈中所有的入栈和出栈，入栈一个新的求解器作用域来将一个标记存储到堆栈的顶部，出栈该求解器作用域来逆转该堆栈上的所有操作，直到它到达该标记为止。

#### Online Scoring
当求解器评估可能的解决方案时，它会跟踪对比当前解决方案的分数以及迄今为止找到的最佳完整解决方案的分数。如果当前解决方案的得分大于最佳完整解决方案的得分，则会放弃当前解决方案并返回继续搜索更好的解决方案。

求解器会先评估较开销比较小的解决方案，然后再评估开销比较大的解决方案。例如，它会倾向于在用户定义转换之前尝试普通转换，倾向于“default”文字类型而不是其他文字类型，倾向于开销更小的转换而不是开销更大的转换。但是，某些规则是临时性的，可以从更多的研究中受益。

#### Arena Memory Management
每个约束系统都引入了自己的内存分配域，使得分配的成本更低，释放的成本也更低。分配域一直扩展到 AST 上下文中，因此由类型变量（例如 `T0 -> T1`）组成的类型将在约束系统的域内而不是在永久域内进行分配。大多数涉及到约束求解的数据结构都使用相同的域。

## Diagnostics
Swift 5.2 引入了一个新的诊断框架，在[这篇博文](https://swift.org/blog/new-diagnostic-arch-overview/)中有详细的描述。

## Footnotes
[1] : 截至撰写本文时，Swift 的类型规则还没有明确地记录在源代码之外。 基于约束的类型检查器包含一个 `matchTypes` 函数，该函数记录并实现每一个规则。将来本文档的修订版将提供更易于访问的版本。

[2] : 更准确地说，在撰写本文时，“将计算”。 求解器当前无法满足计算和合并要求。 而是，它任意选择“下面”的约束条件之一开始。

[3] : 同样，在撰写本文时，求解器并没有实际计算满足和连接，因此求解器将继续执行，直到耗尽可枚举的超类型为止。
